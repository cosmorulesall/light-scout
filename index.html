<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Sunlight + Film Planner POC</title>

<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/suncalc@1.9.0/suncalc.js"></script>

<style>
  body {
    margin: 0;
    background: #111;
    color: #eee;
    font-family: system-ui, sans-serif;
    display: flex;
  }

  #map { flex: 1; height: 100vh; }

  #panel {
  width: 50%;
  max-width: 560px;
  height: 100vh;              /* ‚¨ÖÔ∏è lock panel to viewport height */
  background: #1c1c1c;
  padding: 16px;
  overflow-y: auto;           /* ‚¨ÖÔ∏è vertical scroll only */
  overflow-x: hidden;         /* ‚¨ÖÔ∏è prevent horizontal jitter */
  display: none;
  box-sizing: border-box;     /* ‚¨ÖÔ∏è padding doesn‚Äôt break height */
}

#panel {
  scrollbar-width: thin;              /* Firefox */
  scrollbar-color: #555 #1c1c1c;
}

#panel::-webkit-scrollbar {
  width: 8px;
}

#panel::-webkit-scrollbar-thumb {
  background: #555;
  border-radius: 4px;
}

#panel::-webkit-scrollbar-track {
  background: #1c1c1c;
}

  h3, h4 { margin-top: 0; }

  .row { font-size: 14px; margin-bottom: 6px; }

  input, button {
    width: 100%;
    background: #222;
    color: #eee;
    border: 1px solid #444;
    padding: 6px;
    margin-top: 6px;
  }

  .good { color: #FFD700; }
  .bad { color: #777; }

  .film-group {
    margin-top: 10px;
    padding: 8px;
    background: #222;
    border-left: 3px solid #FFD700;
  }

  .film-title {
    font-weight: bold;
    margin-bottom: 4px;
  }

  .idea {
    margin-top: 8px;
    padding: 8px;
    background: #222;
    border-left: 3px solid #4CAF50;
    font-size: 14px;
  }

  .saved {
    cursor: pointer;
    font-size: 13px;
    margin-top: 6px;
    opacity: 0.9;
  }

.ai-loading {
  font-size: 14px;
  opacity: 0.8;
  padding: 8px;
  background: #1f1f1f;
  border-left: 3px solid #888;
  animation: pulse 1.4s ease-in-out infinite;
}

@keyframes pulse {
  0%   { opacity: 0.4; }
  50%  { opacity: 0.9; }
  100% { opacity: 0.4; }
}
</style>
</head>

<body>

<div id="map"></div>

<div id="panel">
  <h3>üìç Light & Film Explorer</h3>

  <input type="date" id="datePicker"/>

  <div id="astro"></div>

  <h4>‚òÄÔ∏è Sun times</h4>
  <div id="sunTimes"></div>

  <h4>üì∑ Golden hour conditions</h4>
  <div id="ghSummary"></div>

  <h4>‚è± Time of day</h4>
  <input type="range" id="timeSlider"/>
  <div id="timeLabel" class="row"></div>

  <h4>üì∏ Current light</h4>
  <div id="conditions"></div>

  <h4>üéû Film suggestions</h4>
  <div id="filmRec"></div>

<h4>üìç Photo opportunities</h4>
<div id="photoIdeas">
  <div id="aiLoading" class="ai-loading" style="display:none;">
    ü§î Thinking about this scene‚Ä¶
  </div>
  <div id="aiIdeasContent"></div>
</div>

  <button onclick="saveLocation()">üíæ Save location</button>

  <h4>‚≠ê Saved locations</h4>
  <div id="saved"></div>
</div>

<script>
/* ================= MAP ================= */

const map = L.map("map").setView([54.5, -3], 6);
L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png").addTo(map);

let marker, arrow, streetsLayer, buildingsLayer;
let state = null;

map.on("click", e => {
  document.getElementById("panel").style.display = "block";
  map.invalidateSize();

  if (marker) marker.remove();
  marker = L.circleMarker(e.latlng, { radius: 6, color: "#FFD700" }).addTo(map);

  analyseLocation(e.latlng.lat, e.latlng.lng);
});

/* ================= AI HELPERS ================= */

function getTimePhase(el) {
  if (el < -6) return "night";
  if (el < 0) return "blue hour";
  if (el < 12) return "golden hour";
  return "midday";
}

function getStreetAlignment(streets, sunAz) {
  let aligned = 0;
  streets.elements.filter(e => e.geometry).forEach(w => {
    const g = w.geometry;
    const b = bearing(g[0].lat, g[0].lon, g[g.length - 1].lat, g[g.length - 1].lon);
    if (angleDiff(b, sunAz) < 30) aligned++;
  });
  if (aligned > 8) return "strong";
  if (aligned > 3) return "moderate";
  return "weak";
}

function buildAIContext(state, time, az, el) {
  const direct = sunVisible(state.lat, state.lng, az, el, state.buildings);

  return {
    timePhase: getTimePhase(el),
    sunVisible: direct,
    streetAlignment: getStreetAlignment(state.streets, az),
    location: {
      lat: Number(state.lat.toFixed(6)),
      lng: Number(state.lng.toFixed(6)),
      radiusMeters: 300
    }
  };
}

function showAILoading() {
  const el = document.getElementById("aiLoading");
  if (el) el.style.display = "block";
}

function hideAILoading() {
  const el = document.getElementById("aiLoading");
  if (el) el.style.display = "none";
}

function renderPhotoIdeasFromBackend(ideas) {
  const container = document.getElementById("aiIdeasContent");

  if (!container) {
    console.warn("aiIdeasContent not found");
    return;
  }

  container.innerHTML = ideas.map(i => `
    <div class="idea">
      <div><strong>Practical:</strong> ${i.practical}</div>
      <div><strong>Vibe:</strong> ${i.vibe}</div>
      <div><strong>Nearby place:</strong> ${i.nearby}</div>
    </div>
  `).join("");
}

async function fetchPhotoIdeasFromBackend(ctx) {
  const res = await fetch(
    "https://light-scout-api.emil-dimitrov104.workers.dev",
    {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(ctx)
    }
  );

  return res.json();
}

/* ================= ANALYSIS ================= */

function analyseLocation(lat, lng) {
  const dateVal = document.getElementById("datePicker").value;
  const date = dateVal ? new Date(dateVal) : new Date();
  const times = SunCalc.getTimes(date, lat, lng);

  setupSlider(times);

  Promise.all([fetchBuildings(lat, lng), fetchStreets(lat, lng)])
    .then(([buildings, streets]) => {
      const ghGood = intervalHasSun(times.goldenHour, times.sunset, lat, lng, buildings);
      state = { lat, lng, date, times, buildings, streets };
      drawBuildings(buildings);
      renderSunTimes(times, ghGood);
      renderAstro(date);
      updateForTime(times.goldenHour);
    });
}

/* ================= SLIDER & UPDATE ================= */

function setupSlider(times) {
  const s = document.getElementById("timeSlider");
  s.min = times.sunrise.getTime();
  s.max = times.sunset.getTime();
  s.step = 5 * 60 * 1000;
  s.value = times.goldenHour.getTime();
  s.oninput = () => updateForTime(new Date(+s.value));
}

function updateForTime(time) {
  if (!state) return;

  const pos = SunCalc.getPosition(time, state.lat, state.lng);
  const az = (pos.azimuth * 180 / Math.PI + 180) % 360;
  const el = pos.altitude * 180 / Math.PI;

  document.getElementById("timeLabel").textContent =
    `Time: ${time.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" })}`;

  drawSunArrow(state.lat, state.lng, az);
  drawStreets(state.streets, az);
  renderConditions(state.lat, state.lng, az, el, state.buildings);
  renderFilmSuggestions(time, az, el, state.buildings);

const aiCtx = buildAIContext(state, time, az, el);

showAILoading();

fetchPhotoIdeasFromBackend(aiCtx)
  .then(data => {
    hideAILoading();
    renderPhotoIdeasFromBackend(data.ideas);
  })
  .catch(err => {
    hideAILoading();
    console.error("AI fetch failed:", err);
  });
}

/* ================= FILM RECOMMENDER ================= */

function renderFilmSuggestions(time, az, el, buildings) {
  const scene = deriveSceneCondition(time, az, el, buildings);
  const html = [];

  html.push(renderFilmGroup(
    "üé® Colour",
    ["Portra 160", "Portra 400", "Ektar 100"],
    "Wide latitude and smooth highlight roll-off help manage contrast and colour shifts."
  ));

  html.push(renderFilmGroup(
    "‚ö´ Black & White",
    ["HP5+", "Tri-X 400", "FP4+"],
    "Excellent tonal response and flexibility when light contrast changes."
  ));

  if (scene.lowLight) {
    html.push(renderFilmGroup(
      "üåô Night / Low light",
      ["Portra 800", "Cinestill 800T", "Delta 3200"],
      "Higher-speed films cope better as light levels drop and colour temperatures mix."
    ));
  }

  document.getElementById("filmRec").innerHTML = html.join("");
}

function renderFilmGroup(title, stocks, why) {
  return `
    <div class="film-group">
      <div class="film-title">${title}</div>
      <div>${stocks.join(" / ")}</div>
      <div class="row">${why}</div>
    </div>
  `;
}

function deriveSceneCondition(time, az, el, buildings) {
  const direct = sunVisible(state.lat, state.lng, az, el, buildings);
  return {
    lowLight: el < 10
  };
}

/* ================= REST (unchanged logic) ================= */

function fetchStreets(lat,lng){
  return fetch("https://overpass-api.de/api/interpreter", {
    method:"POST",
    body:`[out:json];way["highway"](around:600,${lat},${lng});out geom;`
  }).then(r=>r.json());
}

function fetchBuildings(lat,lng){
  return fetch("https://overpass-api.de/api/interpreter", {
    method:"POST",
    body:`[out:json];way["building"](around:400,${lat},${lng});out geom tags;`
  })
  .then(r=>r.json())
  .then(d=>d.elements.map(b=>({
    geom:b.geometry,
    h:(parseFloat(b.tags?.height)||3)*3
  })));
}

function drawBuildings(b){
  if(buildingsLayer) buildingsLayer.remove();
  buildingsLayer = L.layerGroup(
    b.map(x => L.polygon(x.geom.map(p=>[p.lat,p.lon]),{color:"#555",fillOpacity:0.4}))
  ).addTo(map);
}

function drawStreets(osm, sunAz) {
  if (streetsLayer) streetsLayer.remove();
  streetsLayer = L.geoJSON(osm.elements.filter(e=>e.geometry).map(w=>{
    const g=w.geometry;
    const b=bearing(g[0].lat,g[0].lon,g[g.length-1].lat,g[g.length-1].lon);
    const diff=angleDiff(b,sunAz);
    return {
      type:"Feature",
      properties:{color: diff<30?"#FFD700":diff<60?"#FFA500":"#444"},
      geometry:{type:"LineString",coordinates:g.map(p=>[p.lon,p.lat])}
    };
  }),{style:f=>({color:f.properties.color,weight:3})}).addTo(map);
}

function drawSunArrow(lat,lng,az){
  if(arrow) arrow.remove();
  const r=az*Math.PI/180;
  arrow=L.polyline([[lat,lng],[lat+Math.cos(r)*0.001,lng+Math.sin(r)*0.001]],
    {color:"#FFD700",weight:3}).addTo(map);
}

function renderConditions(lat,lng,az,el,b){
  const g=sunVisible(lat,lng,az,el,b);
  document.getElementById("conditions").innerHTML =
    `<div class="row ${g?"good":"bad"}">${g?"Direct sunlight likely":"Sun obstructed by buildings"}</div>`;
}

function renderSunTimes(t,g){
  const f=x=>new Intl.DateTimeFormat(undefined,{hour:"2-digit",minute:"2-digit"}).format(x);
  document.getElementById("sunTimes").innerHTML=
    `<div class="row">üåÖ Sunrise: ${f(t.sunrise)}</div>
     <div class="row">üåá Sunset: ${f(t.sunset)}</div>
     <div class="row">üåÑ Golden hour: ${f(t.goldenHour)} ‚Äì ${f(t.sunset)}</div>`;
  document.getElementById("ghSummary").innerHTML=
    `<div class="row ${g?"good":"bad"}">${g?"Golden hour likely good":"Golden hour obstructed"}</div>`;
}

function intervalHasSun(start,end,lat,lng,b){
  for(let t=new Date(start);t<=end;t.setMinutes(t.getMinutes()+15)){
    const p=SunCalc.getPosition(t,lat,lng);
    const az=(p.azimuth*180/Math.PI+180)%360;
    const el=p.altitude*180/Math.PI;
    if(el>0&&sunVisible(lat,lng,az,el,b))return true;
  }
  return false;
}

function renderAstro(d){
  const m=SunCalc.getMoonIllumination(d);
  document.getElementById("astro").innerHTML =
    m.phase<0.02||m.phase>0.98?"üåë New Moon":"";
}

function saveLocation(){}
function bearing(a,b,c,d){const y=Math.sin((d-b)*Math.PI/180)*Math.cos(c*Math.PI/180);
const x=Math.cos(a*Math.PI/180)*Math.sin(c*Math.PI/180)-
Math.sin(a*Math.PI/180)*Math.cos(c*Math.PI/180)*Math.cos((d-b)*Math.PI/180);
return(Math.atan2(y,x)*180/Math.PI+360)%360;}
function angleDiff(a,b){const d=Math.abs(a-b)%360;return d>180?360-d:d;}
function dist(a,b,c,d){const R=6371000;
const dLat=(c-a)*Math.PI/180;const dLon=(d-b)*Math.PI/180;
const h=Math.sin(dLat/2)**2+Math.cos(a*Math.PI/180)*Math.cos(c*Math.PI/180)*Math.sin(dLon/2)**2;
return 2*R*Math.asin(Math.sqrt(h));}
function sunVisible(lat,lng,az,el,b){
for(const x of b){const c=x.geom[0];const d=dist(lat,lng,c.lat,c.lon);
const br=bearing(lat,lng,c.lat,c.lon);
if(angleDiff(az,br)<15 && Math.atan2(x.h,d)*180/Math.PI>el)return false;}
return true;}
</script>

</body>
</html>

